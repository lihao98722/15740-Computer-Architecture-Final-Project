#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>

int NUM_THREADS = 3;
int globalX = 0;
FILE *f;

int print(const char *fmt, ...)
{
    int res;
    va_list args;
    va_start(args, fmt);

    res  = vprintf(fmt, args);
    res += vfprintf(f,  fmt, args);
    fflush(f);
    va_end(args);
    return res;
}

/*
 * thread - synthetically create data races 
 */

void *
thread(void *v)
{
    int temp = 0;
    int t1 =0;
    int t2 = 0;
    int t3 = 0;
    int id = (int)v;

    printf("Thread %d started\n", id);
    switch(id) 
    {
      case 0:
        temp = globalX;
	t1 = globalX;
	t2 = globalX;
	t3 = globalX;
        printf("Thread %d: Read globalX as %d\n", id, temp);
        sleep(5);
        globalX = temp + 1;
        printf("Thread %d: Update globalX as %d\n", id, temp+1);        
        sleep(5);
        break;
      case 1:
        sleep(1);
        temp = globalX;
        printf("Thread %d: Read globalX as %d\n", id, temp);
        globalX = temp + 1;
        printf("Thread %d: Update globalX as %d\n", id, temp+1);        
        sleep(3);
          break;
      default:
        sleep(3);
        temp = globalX;
        printf("Thread %d: Read globalX as %d\n", id, temp);
        sleep(5);
        globalX = temp + 1;
        printf("Thread %d: Update globalX as %d\n", id, temp+1);        
        sleep(1);
        break;
    }

    printf(__FILE__ ": thread %d finished\n", id);
    return 0;
}

int
main(int argc, char **argv)
{
    pthread_t *threads;
    int i;

    if( argc > 1 ) 
    {
        NUM_THREADS = atoi(argv[1]);
    }

    threads = malloc(sizeof(pthread_t) * NUM_THREADS);
    for( i = 0; i < NUM_THREADS; i++ ) 
    {
        printf("creating %d\n", i);
        if( pthread_create(&threads[i], NULL, thread, (void *)i) != 0 ) 
        {
            perror("pthread_create");
        }
    }


    for( i = 0; i < NUM_THREADS; i++ ) 
    {
        pthread_join(threads[i], NULL);
    }

    printf("globalX = %d\n", globalX);
    return 0;
}
